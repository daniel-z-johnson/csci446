1. Though HTTP protocols are stateless it possible to emulated statefulness through cookies. The cookies will store session information and from that information the sever will be able to change the web-page to the proper state for the user. This can be done through the url also, though it is not also possible or advisable to do this because some stuff shouldn't be displayed in the url, like a password.

It also possible to change the state dynamically with Javascript. This is usually done with a JavaScript library such as JQuery. The Javascript usually makes a request to the server and receives information. Using this information it can post information on the page as it changes.

2. A great thing about using third-party libraries for authentication is that it is often possible to have the library generate everything that is needed for authentication, and everything will work, if it is a good library. You need not worry about hashing and salting the password or making sure the input from the user is censored when it comes to password and confirm password. It is all done for you already, if it is a good library. You have to do research to make sure it is a good library that does everything right.

One disadvantage though that is sometimes a hassle to make changes to the generated authentication if you need to make changes. If you have to make enough changes it can become even more work that rolling your own. Also, some third-party authentication may add a lot more than you need or want. So sometimes it is very advantageous to roll your own authentication rather than relying on someone else's, though make sure to not to store the password as plain text and censored the user's input when it comes to the password and a few other things.

3. The way that rails manages is through migrations. Migrations are ruby source files that are generated for models in order to tell the database what tables to make and when to modify a table. Migrations currently begin with several numbers then an underscore then the name of the migration. The numbers are in the form of yyyyMMddhhmmss, where yyyy is year, MM is month, dd is day, hh is hour, mm is minute and ss is secound. This is so rails can keep track of which migration came before another migration. It also helps rails know which migration has been applied and which ones haven't been applied. These numbers are called the ID and it should be unique to the migration.

I believe that migrations are effective tool to keep track of database schema changes. Each migration can be executed separately making it effective for version control on the database. It simplifies altering your database by handling all the SQL for you and replacing them with simple commands such as add_column, rename_column, and change_column. Migrations also allow the user to set restrictions on the columns such as default values and disallowing null values. Though SQL is not difficult it is nice to have a way to simplify it with ruby code. Though if one feels the need to use SQL one can, though it shouldn't be necessary unless one wants something very pacific or something that rails thinks is a bad idea like having a non-integer be the primary key.

One of the few disadvantages of migrations is that it is theoretical possible that when multiply people are writing migrations for the same rails project to get two migrations with the same ID. If this happens rails should throw an error or something will brake unexpectedly in the application. Also, it is possible that when a migrations fails, for whatever reason, that the parts of the migration that succeeded will have to be rolled back my hand or the database dropped and all migration will have to be reapplied, if there is data in the database then it will have to be restored from a back up, the most recent back up if there is a back up, there should be one.

4. Since I think of walking the dog and feeding the dog as functions it doesn't really fit into CRUD, because CRUD usually means a relational database and relational databases do not support storing functions. The function will have to be independent of the data and when someone walks the dog data from the database will have to be fed into the function and then the data will be updated appropriately. This is can be bad because everyone working on the data will have to know of walking the dog function and what it does.

SOAP stand for simple object access protocol and relies on XML to pass around structured information. WSDL stands for web service description language and it is a xml language that is used for describing how web service is supposed to act. It is machine readable, it describes what services are supported how to call them and what parameters it expects.

SOAP relies more on XML and RESTful relies on HTTP protocols such as get and post. SOAP seems to be better at transferring attachments. It seems that over all SOAP needs to send more information that RESTful. One thing that is nice about SOAP it implements strict types.

5. One architecture is where the entire logic and data lays on the server and the browser does little more then render what the server delivers and makes request. One big advantage to this is that it is easier to do security. Since no of the logic lies on the client side then you do not need to worry about something going wrong with the logic because if it works on the server then it will work for all clients because the client can only make requests and if the server can understand the request then it will do the right thing for the request. One disadvantage though is that if you have a lot of clients making requests then the server is more likely that high latency will occur the server will get overloaded and crash.

Anther one is where the server delivers the page initially but with that page it also servers some logic in the form of something like Javascript, Ajax, or JQuery. Then the page can be dynamically updated without a having to be refreshed. There a few advantages to this, first it takes some of the load off the server and places it on the client. It also now possible to display information from multiply servers on one page. One very huge disadvantage to this architecture is that if the client happens to have Javascript disabled then site will likely seem very broken to the client. Also, sometimes the same JavaScript code works differently on different browsers, though it is getting better with time. Another disadvantage is that having all the logic on the client side can open security holes and may make it possible for the client to send corrupted data and break the logic of the database.

Another one is a hybrid between the two, where some of the application logic takes place on the server and some of it also takes place on the client side. The advantages can be, there are a lot of ways you can do this, that you have the security advantages of the server side while having the dynamic capabilities of the client side. Also, you can have multiply services on one page with a main application that depends on the server. While this gets advantages from the two that are above it also can inherited the disadvantages as well, the server will still have a heaver load and if the client doesn't have JavaScript enable then the application may seem broken. You can even have security issues depending how much logic you have on the client side. Though if you balance it out well enough you can have a application that will have great security. It could also run fine without JavaScript enable, though it will probably run better with Javascript enable.
